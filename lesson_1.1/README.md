# Lesson 1. Node js вступление. 

- Node.js. NPM
- Базовые модули Node.js
- Работа с файловой системой. модуль fs
- Прямой доступ к файлам. переменная path
- Nodemon, мониторинг изменений в файлах Node.js


## Node.js в двух словах
### Начало работы с Node.js

![](http://blog-assets.risingstack.com/2016/Mar/node_js_logo_in_node_hero_getting_started_tutorial-1458726703612.png)
*Официальное лого Node.js*

*Node.js — это среда выполнения JavaScript. Платформа Node.js построена на базе JavaScript движка V8 от Google, который используется в браузере Google Chrome. В основе Node.js лежит **событийно-управляемая модель с неблокирующими операциями I/O**, что делает её легкой и эффективной.*

Node.js — это опенсорсная кроссплатформенная среда выполнения для JavaScript, которая работает на серверах. С момента выпуска этой платформы в 2009 году она стала чрезвычайно популярной и в наши дни играет весьма важную роль в области веб-разработки. Если считать показателем популярности число звёзд, которые собрал некий проект на GitHub, то Node.js, у которого более 50000 звёзд, это очень и очень популярный проект. 

Данная платформа, в основном, используется для создания веб-серверов, однако сфера её применения этим не ограничивается.

Кроме того, Node.js поставляется со множеством полезных модулей, так что вам не придется писать всё с нуля, как, например, вывод строки в консоль.

Таким образом, Node.js состоит из 2 вещей: среды исполнения и полезных библиотек.

В Node.js используется libuv - кросс-платформенная библиотека поддержки с акцентом на асинхронный ввод-вывод.

![](http://blog-assets.risingstack.com/2016/Mar/libuv_logo_in_node_hero_getting_started_tutorial-1458726737329.png)
*Официальное лого libuv*

С точки зрения разработчика, Node.js однопоточна, но под капотом **libuv использует треды, события файловой системы, реализует цикл событий, включает в себя тред-пулинг** и так далее. В большинстве случаев вы не будете взаимодействовать с libuv напрямую.

### Рассмотрим основные особенности Node.js.

▍Скорость

Одной из основных привлекательных особенностей Node.js является скорость. JavaScript-код, выполняемый в среде Node.js, может быть в два раза быстрее, чем код, написанный на компилируемых языках, вроде C или Java, и на порядки быстрее интерпретируемых языков наподобие Python или Ruby. Причиной подобного является неблокирующая архитектура платформы, а конкретные результаты зависят от используемых тестов производительности, но, в целом, Node.js — это очень быстрая платформа.

▍Простота

Платформа Node.js проста в освоении и использовании. На самом деле, она прямо-таки очень проста, особенно это заметно в сравнении с некоторыми другими серверными платформами.

▍JavaScript

В среде Node.js выполняется код, написанный на JavaScript. Это означает, что миллионы фронтенд-разработчиков, которые уже пользуются JavaScript в браузере, могут писать и серверный, и клиентский код на одном и том же языке программирования без необходимости изучать совершенно новый инструмент для перехода к серверной разработке.
В браузере и на сервере используются одинаковые концепции языка. Кроме того, в Node.js можно оперативно переходить на использование новых стандартов ECMAScript по мере их реализации на платформе. Для этого не нужно ждать до тех пор, пока пользователи обновят браузеры, так как Node.js — это серверная среда, которую полностью контролирует разработчик. В результате новые возможности языка оказываются доступными при установке поддерживающей их версии Node.js.

▍Движок V8

В основе Node.js, помимо других решений, лежит опенсорсный JavaScript-движок V8 от Google, применяемый в браузере Google Chrome и в других браузерах. Это означает, что Node.js пользуется наработками тысяч инженеров, которые сделали среду выполнения JavaScript Chrome невероятно быстрой и продолжают работать в направлении совершенствования V8.

▍Асинхронность

В традиционных языках программирования (C, Java, Python, PHP) все инструкции, по умолчанию, являются блокирующими, если только разработчик явным образом не позаботится об асинхронном выполнении кода. В результате если, например, в такой среде, произвести сетевой запрос для загрузки некоего JSON-кода, выполнение потока, из которого сделан запрос, будет приостановлено до тех пор, пока не завершится получение и обработка ответа.

JavaScript значительно упрощает написание асинхронного и неблокирующего кода с использованием единственного потока, функций обратного вызова (коллбэков) и подхода к разработке, основанной на событиях. Каждый раз, когда нам нужно выполнить тяжёлую операцию, мы передаём соответствующему механизму коллбэк, который будет вызван сразу после завершения этой операции. В результате, для того чтобы программа продолжила работу, ждать результатов выполнения подобных операций не нужно.

Для этого был придуман механизм [event loop](https://www.youtube.com/watch?v=8cV4ZvHXQL4)

Подобный механизм возник в браузерах. Мы не можем позволить себе ждать, скажем, окончания выполнения AJAX-запроса, не имея при этом возможности реагировать на действия пользователя, например, на щелчки по кнопкам. Для того чтобы пользователям было удобно работать с веб-страницами, всё, и загрузка данных из сети, и обработка нажатия на кнопки, должно происходить одновременно, в режиме реального времени.

Если вы создавали когда-нибудь обработчик события нажатия на кнопку, то вы уже пользовались методиками асинхронного программирования.

Асинхронные механизмы позволяют единственному Node.js-серверу одновременно обрабатывать тысячи подключений, не нагружая при этом программиста задачами по управлению потоками и по организации параллельного выполнения кода. Подобные вещи часто являются источниками ошибок.

Node.js предоставляет разработчику неблокирующие базовые механизмы ввода вывода, и, в целом, библиотеки, использующиеся в среде Node.js, написаны с использованием неблокирующих парадигм. Это делает блокирующее поведение кода скорее исключением, чем нормой.

Когда Node.js нужно выполнить операцию ввода-вывода, вроде загрузки данных из сети, доступа к базе данных или к файловой системе, вместо того, чтобы заблокировать ожиданием результатов такой операции главный поток, Node.js инициирует её выполнение и продолжает заниматься другими делами до тех пор, пока результаты выполнения этой операции не будут получены.

[Node js вступление](https://habr.com/company/ruvds/blog/422893/)

## Установка Node.js для старта

Последнюю версию Node.js вы можете найти на официальном сайте: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).

При таком подходе довольно легко начать работу, но если позже вы захотите добавить в систему больше версий Node.js, лучше начать использовать [nvm](https://github.com/creationix/nvm) (*node version manager*) - диспетчер версий Node.js.

После его установки вы сможете использовать очень простой CLI API для смены версии Node.js:

Чтобы убедиться, что у вас установлена и запущена Node.js, выполните:

```
node -v
```

Если все в порядке, эта команда вернет номер версии текущего активного бинарного файла Node.js.

Проверяем версию -  node -v //получаем текущую версию

В Node.js доступны многие методы, за исключением Alert и работы с DOM-деревом, но можно вызвать привычное console.log

**Хорошо, теперь мы знаем, как устанавливать Node.js и переключаться между её версиями, но в чём смысл?**

С тех пор как был сформирован Node.js Foundation, Node.js имеет план релизов. Это очень похоже на другие проекты Linux Foundation. Это означает, что есть два релиза: стабильный и экспериментальный. В Node.js стабильными версиями с долговременной поддержкой (LTS) являются те, которые начинаются с четных чисел (4, 6, 8, ...). Экспериментальные версии нумеруются нечетными числами (5, 7, ...).

Мы рекомендуем использовать версию LTS в продакшене и пробовать новые возможности с экспериментальной версией.

## Hello World

Чтобы начать работу с Node.js, давайте попробуем её в консоли! Запустите Node.js, просто набрав `node` и нажмите Enter:

```
$ node
>
```

Хорошо, давайте попробуем что-то напечатать:

```
$ node
> console.log('hello from Node.js')
```

После нажатия Enter вы получите следующее:

```
> console.log('hello from Node.js')
hello from Node.js
undefined
```

Пришло время создать наше приложение Hello Node.js!

Начнем с создания файла `index.js`. Откройте свою IDE (Atom, Sublime, Code — выбор за вами), создайте новый файл и сохраните его с именем `index.js`. Если вы закончили, скопируйте в него следующий фрагмент кода:

```
// index.js
console.log('hello from Node.js')
```

Чтобы запустить этот файл, вы должны снова открыть свой терминал и перейти в каталог, в котором размещён `index.js`.

Как только вы успешно переместитесь в нужное место, запустите файл, используя команду `node index.js`. Вы увидите, что эта команда будет выдавать тот же результат, что и раньше, выводя строку непосредственно в терминале.

## Модульность для вашего приложения

Каждый проект Node.js начинается с создания файла `package.json`. Вы можете думать о нем как о JSON-представлении приложения и его зависимостей. Он содержит имя вашего приложения, автора (вас) и все зависимости, необходимые для запуска приложения. *Мы рассмотрим раздел зависимостей позже в главе «Использование NPM».*

Вы можете интерактивно генерировать файл `package.json` с помощью команды `npm init` в терминале. После запуска команды вас попросят ввести некоторые данные, например имя вашего приложения, версию, описание и так далее. Не нужно беспокоиться, просто нажимайте Enter, пока не получите сформированный JSON и вопрос `is it ok?`. Нажмите Enter в последний раз и вуаля: ваш `package.json` был автоматически сгенерирован и помещен в папку вашего приложения.
Можно сократить процес и сразу задать `npm init -y`
 Если вы откроете этот файл в своей IDE, он будет очень похож на фрагмент кода ниже.

```javascript
// package.json
{
  "name": "@node-hero",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node index.js"
  },
  "author": "", "license": "ISC"
}
```

Хорошей практикой является добавление стартового скрипта в ваш пакет `package.json`. Как только вы это сделаете, как показано в примере выше, вы можете запустить приложение с помощью команды `npm start`. Это очень удобно, когда вы хотите развернуть свое приложение у PaaS-провайдера: они могут распознать команду `start` и использовать её для запуска приложения.

# NPM

## Использование NPM

Каждый проект Node.js начинается с создания файла package.json. Вы можете думать о нем как о JSON-представлении приложения и его зависимостей. Он содержит имя вашего приложения, автора (вас) и все зависимости, необходимые для запуска приложения.

## NPM в двух словах

NPM — это менеджер пакетов, используемый Node.js-приложениями. В нём вы можете найти массу готовых модулей, поэтому вам не нужно изобретать колесо. Это похоже на Maven для Java или Composer для PHP. Существует два основных интерфейса, с которыми вы будете взаимодействовать: сайт NPM и набор инструментов командной строки (CLI).

И веб-сайт, и CLI используют один и тот же реестр, чтобы искать и отображать модули.

## Вебсайт

Сайт NPM можно найти по адресу [https://npmjs.com](https://npmjs.com). Здесь вы можете зарегистрироваться как новый пользователь или поискать нужные пакеты.

![](NodeHeroEbook-TheComplete-008.png)

Обратите внимание, что NPM поставляется вместе с бинарным файлом Node.js, поэтому вам не нужно его устанавливать, однако если вы хотите использовать определенную версию NPM, вы можете его обновить. Если вы хотите установить NPM версии 6, вы можете сделать это с помощью: `npm i npm@ -g`.

С помощью npm можно устанавливать пакеты (библиотеки) локально или глобально. В локальном режиме пакеты устанавливаются в каталог node_modules родительского каталога.  

Пакеты можно ставить локально ```npm i <package-name>``` и глобально локально ```npm i <package-name> -g```



[Введение в пакетный менеджер](http://prgssr.ru/development/vvedenie-v-paketnyj-menedzher-npm-dlya-nachinayushih.html)

Часть зависимостей необходимо добавлять только к вашему приложению. Когда у вас есть файл `package.json`, вы можете добавить зависимости к вашему приложению. 

```
npm i lodash
```

С помощью этой единственной команды мы достигли двух вещей: во-первых, `lodash` загружен и помещён в папку `node_modules`. Это папка, в которой будут находиться все ваши внешние зависимости. Обычно вы не хотите добавлять её в свою систему управления версиями, поэтому, если вы используете git, обязательно добавьте `node_modules` в файл `.gitignore`.

---

Давайте посмотрим, что происходит в файле `package.json`! Появилось новое свойство, называемое `dependencies`:

```javascript
"dependencies": {
  "lodash": "4.17.1"
}
```

Это означает, что `lodash` версии `4.17.1` теперь установлен и готов к использованию. Обратите внимание, что NPM следует правилам SemVer для версионирования пакетов.

> _Используя нумерацию версий вида MAJOR.MINOR.PATCH, повышайте MAJOR-версию, когда вы делаете несовместимые изменения API, MINOR-версию, когда вы добавляете функциональность обратно-совместимым образом, и PATCH-версию, когда вы делаете исправления ошибок с обратной совместимостью. Для получения дополнительной информации: [http://semver.org/](http://semver.org/)_

Поскольку `lodash` готов к использованию, давайте посмотрим, как мы можем им воспользоваться! Вы можете сделать это так же, как и с вашим собственным модулем, но теперь вам не нужно указывать полный путь, достаточно только имени модуля, что бы его подключить через require('lodash'):

```javascript
// index.js
const _ = require("lodash");
```

### Подключение скриптов: require
    
В браузере, когда мы хотим добавить еще один скрипт на страницу мы используем, как правило тег: <script></script>. В Node.JS для этой же цели мы используем специальную команду: «require» и работает она совсем, совсем по другому.

#### Пример

Файл 1
```
const module = {
    app: 'myApp' 
};

module.exports = module

```

Файл 2
```
cosnt myModule = require('./module');

console.log(myModule);
```

## Добавление зависимостей для разработки

**В этом разделе вы узнаете, как добавлять зависимости, необходимые только во время сборки приложения.**

Когда вы собираете веб-приложения, вам может потребоваться минимизировать ваши JavaScript-файлы, объединить CSS-файлы и так далее. Модули, которые это сделают, будут выполняться только во время создания ресурсов, поэтому работающее приложение не нуждается в них.

Вы можете установить такие скрипты с помощью:

```javascript
npm i mocha --save-dev
```

После этого в вашем файле `package.json` появится новый раздел, называемый `devDependencies`. Все модули, которые вы устанавливаете с помощью `--save-dev`, будут описаны там, а также они будут помещены в тот же самый каталог `node_modules`.

## NPM-скрипты

NPM-скрипты — очень мощная концепция, с их помощью вы можете создавать небольшие утилиты или даже описывать сложные системы сборки.

Наиболее распространенными являются скрипты `start` и `test`. С помощью `start` вы можете описать, как нужно запускать приложение, а `test` используется для запуска тестов. В вашем `package.json` они могут выглядеть примерно так:

```javascript
"scripts": {
  "start": "node index.js",
  "test": "mocha test",
  "your-custom-script": "echo npm"
}
```

**Что следует здесь отметить:**

- `start`: просто описывает начальную точку для запуска вашего приложения, этот скрипт можно вызвать с помощью `npm start`.
- `test`: цель этого скрипта заключается в том, чтобы запускать ваши тесты: одно из удобств такого запуска тестов заключается в том, что в этом случае `mocha` не нужно устанавливать глобально, так как NPM будет искать её в папке `node_modules/.bin`, а `mocha` будет размещена там же. Запуск тестов может быть вызван с помощью `npm test`.
- `your-custom-script`: всё, что вы захотите (вы можете выбрать любое имя). Его можно вызвать с помощью `npm run your-custom-script` — не забывайте про `run` в этом случае!

## Ограничение области видимости и приватные пакеты

Первоначально у NPM было глобальное пространство имен для названий модулей, и с более чем 250 000 модулями в реестре большинство простых имен уже заняты. Кроме того, глобальное пространство имен содержит только общедоступные модули.

В NPM урегулировали эту проблему внедрением пакетов с ограниченной областью видимости (_scoped packages_), они имеют следующий шаблон именования:

```
@myorg/mypackage
```

Вы можете устанавливать пакеты с ограниченной областью видимости так же, как и раньше:

```
npm install @myorg/mypackage --save-dev
```

Они будут отображаться в вашем `package.json` следующим образом:

```javascript
"dependencies": {
  "@myorg/mypackage": "^1.0.0"
}
```

Подключение пакетов с ограниченной областью видимости:

```javascript
require("@myorg/mypackage");
```

_Для получения большей информации обратитесь к [документации NPM-модулей с ограниченной областью видимости](https://docs.npmjs.com/misc/scope)._

---

# Разбираемся с версиями пакетов в node

Итак когда мы устанавливаем какой-то пакет, например, express, то в package.json добавляется последняя версия пакета, состоящая из трех цифр. Эти цифры означают Major, Minor, Patch и используют как спецификацию semver.

Что это значит? Когда я делаю пакет и еще не опубликовал его, то первая цифра идет 0. Это значит, что какие бы номера версий не шли дальше, я могу в любом момент менять любой функционал пакета. Потому что пакет, начинающийся с 0 - нестабильный пакет.

Когда мы опубликовали пакет, то каждый номер версии начинает иметь смысл. Последняя цифра - это PATCH. То есть внесение незначительных изменений в пакет, например bugfix.

Средняя цифра - это минорная версия. Она должна обновляться при изменениях, которые добавляют новый функционал, но не ломают то, что уже работает. Таким образом любой человек может обновится с 1.2.0 на 1.3.0 и все должно по прежнему работать.

Первая же цифра - это мажорная версия. Если внеслись хоть какие-то изменения, которые сломали текущий код, то должна релизится новая мажорная версия. Это может быть как изменение API, так и изменение порядка аргументов. Поэтому нужно делать версию 2.0.0.

Собственно вся система версий и пакетов подчиняется спецификации semver, о которой вы можете почитать на сайте semver.org.

Теперь немного о дополнительных символах при версии пакета.

Мы можем указать, что пакет должен быть больше версии 1.2.7

> = 1.2.7
> Тогда, при установке пакетов версия будет искаться только среди версий, которые больше 1.2.7.

Также можно указывать range.

> =1.2.7 <1.3.0
> Также есть специальные пре релизные теги.

1.2.3-alpha.3
1.2.3-beta.0
Также часто встречаются тильда и каретка.

Когда у нас стоит тильда

~1.2.3
Это значит, что версия может меняться только от 1.2.3 до 1.3.0, то есть могут применятся только патчи, а минорная версия обновлятся не может.

Если же у нас стоит каретка

^1.2.3
То можно обновлять и минорную версию и накатывать патчи. То есть от 1.2.3 до 2.0.0.

---

# Разбираемся с lock файлами в npm

Что такое lock файлы вообще? В разных языках для установки пакетов существуют пакетные менеджеры. Например, в node - это npm. И когда мы устанавливаем пакеты, то мы должны быть уверены, что мы все время будем устанавливать одинаковую версию пакетов. Потому что любое, даже минорное обновление, может все поломать.

Очень много людей считает, что если в package.json указать точные версии пакетов, но они никогда не обновятся и проект в безопасности. Это абсолютно не так. В чем же проблема?

Да, указав версию пакета, например, в 1.5.0 мы всегда будем устанавливать этот пакет именно версии 1.5.0. Но у каждого пакета есть свои зависимости. И мы никогда не знаете, как он их менеджит. Возможно, он не лочит их на конкретной версии. А даже если и лочит, то зависимости зависимостей могут иметь не точные версии. Поэтому, рано или поздно, с большим количеством пакетов на проекте, при очередной установке пакетов все может поломаться и прийдется долго дебажить, почему.

Эту проблему решают с помощью lock файлов. Что это такое? Это дополнительный файл, который генерируется автоматически и хранит в себе полное дерево всех зависимостей с версиями. И после его генерации все пакеты устанавливаются по новой с версиями и зависимостями, которые там указаны.

По умолчанию в npm 5, которая на данным момент последняя, при установке пакетов у вас автоматически создается и обновляется файл package-lock.json. Вам не нужно ничего дополнительно делать. Вы просто должны закоммитить этот файл также, как и обычный файл проекта в репозиторий.

Если же вы используете yarn, вместо npm, то у вас также автоматически генерируется файл yarn.lock, который лочит все версии.

Если же вы все еще используете более старый npm, то lock файл у вас не будет создаваться руками. Для создания его нужно выполнить команду

```javascript
npm shrinkwrap
```

В результате у вас создастся файл npm-shrinkwrap.json, в котором будут залочены все зависимости.

Какой бы язык или пакетный менеджер вы не использовали, вы всегда должны использовать lock файлы, во избежание дебага обновившихся пакетов.

Также, я бы рекомендовал все всегда использовать точные версии в package.json. Тогда, если кто-то удалит lock файл, шанс, что при установке пакетов что-то отлетит все таки меньше.



## Базовые модули Node.js



### Переменная «global»
Что если мы хотим все таки глобальные переменные? Например есть такие объекты как скажем «logger» или «База данных» или какой то глобальный объект приложения, которые мы хотим, чтобы были доступны явно и везде. Без всяких там экспортов, просто потому что они, такие вот важные. На самом деле в Node.JS есть концепция глобальных переменных, но вместо объекта «window», который используется в браузере, используется объект «global».  И то, что мы пишем в этот объект «global». Работает он так же как и window в браузере.


# Файлы ввода/вывода с node.js

К счастью, Node.js сильно облегчает обработку содержания файла с помощью встроенного модуля filesystem (fs). 

### FS (file system) модуль

В Node.JS, для работы с файлами существует модуль «FS» и в нем есть множество функций для самых различных операций с файлами и директориями. 

#### Базовые операции

- Read files
- Create files
- Update files
- Delete files
- Rename files

[Ссылка на документацию](https://js-node.ru/site/article?id=23)

Есть одинаковые методы как `fs.copyFile()` и `fs.copyFileSync()`

Первое просто имя, второе со словом Sync. Слово Sync означает синхронно.Если я например вызову fs.readFile(file[, options], callback), то он сначала прочитает файл полностью, а потом вызовет callback. А fs.readFileSync(file[, options]) затормозит выполнение процесса пока файл не будет прочитан. По этому, как правило синхронный вызов используют либо в консольных утилитах, либо на стадии инициализации сервера, когда такие тормоза допустимы. А асинхронный вызов, в тех случаях когда хочется, чтоб полноценно работал событийный цикл, то есть, чтоб Node.JS не ждал пока диск сработает, медленно и файл прочитается.

[Ссылка на статью с примерами](https://www.w3schools.com/nodejs/nodejs_filesystem.asp)

Модуль fs имеет функцию readFile, которая берёт путь к файлу и обратный вызов. Обратный вызов будет исполнен, когда файл будет полностью прочитан. Данные файла попадают в форме типа Buffer, что является набором битов.

```javascript
//hello.js
const fs = require("fs");

fs.readFile("hello.txt", "utf8", (error, content) =>
  content
    .split("\n")
    .filter(line => line.includes("dog"))
    .forEach(line => console.log(line))
);
```

```
//hello.txt

fluffykins is a dragon
wolfbane is a dragon
kittylunch is a cat
karo is a dog
multidog is a dog
```


### path модуль

Модуль path предоставляет утилиты для работы с путями к файлам и директориям.
С помощью нее мы можем взять файл который нам нужен и передав его в другой модуль (например fs) сделать нужные операции.


Пример:
```
path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')
// Возвращает: '/foo/bar/baz/asdf'

path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')
// если текущая рабочая директория /home/myself/node,
// Возвращает '/home/myself/node/wwwroot/static_files/gif/image.gif'

```

[Все методы модуля](https://js-node.ru/site/article?id=30)

#### Ключевое слово __dirname

В Node.js, `__dirname` всегда находится каталог, в котором находится текущий исполняемый script. Поэтому, если вы набрали `__dirname` в `/d1/d2/myscript.js`, значение будет `/d1/d2`.

# Node js потоки

- Синхронность, асинхронность процессов
    - синхронные асинхронные методы
    - event loop
    - promise object
    - async, await 
- Потоки в node js

## Синхронность, асинхронность процессов

В традиционной практике программирования большинство операций ввода-вывода происходит синхронно. 

Что происходит в фоновом режиме? Основной поток будет заблокирован до тех пор, пока файл не будет прочитан, а это означает, что за это время ничего другого не может быть сделано. Чтобы решить эту проблему и лучше использовать ваш CPU, вам придется управлять потоками вручную.

Если у вас больше блокирующих операций, очередь событий становится ещё хуже:

<img src='./images/12.jpg' />

Красные полосы отображают промежутки времени, в которые процесс ожидает ответа от внешнего ресурса и блокируется, чёрные полосы показывают, когда ваш код работает, зелёные полосы отображают остальную часть приложения

Для решения этой проблемы Node.js предлагает модель асинхронного программирования.

[Асинхронное програмирование в node js](https://medium.com/devschacht/node-hero-chapter-3-cae7333c7f3d)

## Event loop

Цикл событий (Event Loop) — это то, что позволяет Node.js выполнять неблокирующие операции ввода/вывода (несмотря на то, что JavaScript является однопоточным) путем выгрузки операций в ядро системы, когда это возможно.

[Лучшее видео об event loop](https://www.youtube.com/watch?v=8cV4ZvHXQL4)

[Ссылка на презентацию по event loop](https://drive.google.com/open?id=1OBMSG1HyNa13DtI_J_csFMvk0O6S9pQK)

### Promise


В JavaScript «промисы» представляет собой конечный результат выполнения асинхронной операции. Их можно рассматривать в качестве своеобразного «заполнителя». Такой «заполнитель», по существу, является объектом, к которому мы можем привязать функции обратного вызова (колбэки).

Всего существует 3 возможных состояния для промисов:

- Pending (ожидание) означает, что асинхронная операция выполняется;
- Fulfilled (успешное выполнение) означает, что операция была выполнена успешно, а промисам было присвоено определенное значение;
- Rejected (выполнено с ошибкой) означает, что во время выполнения операции произошла ошибка.


В том случае если состояние промиса не находится в ожидании обработки (pending), то промис считается выполненным, при чем выполненным окончательно: его состояние не может меняться.


[Статья по промисам 1](https://habr.com/company/zerotech/blog/317256/)
[Статья по промисам 2](https://blog.liveedu.tv/javascript-promises/)

#### Видео по промисам

- https://www.youtube.com/watch?v=SjNmkeUpQAU
- https://www.youtube.com/watch?v=s6SH72uAn3Q

## Потоки в node js (Streams)

Поток — это концепция, которая была сначала реализована в UNIX системах для передачи данных из одной программы в другую в операциях ввода/вывода. Это позволяет каждой программе быть очень специализированной в том, что она делает — быть независимым модулем. Сочетание таких простых программ помогает в создании более сложных систем путем «объединения» их в цепочку вызовов.

Распространенная задача — парсинг файла большого объема. Например, в текстовом файле с данными логов нужно найти строку, содержащую определенный текст. Вместо того, чтобы файл полностью загрузить в память, и потом начать разбирать в нем строки в поисках нужной, мы можем его считывать небольшими порциями. Тем самым не занимаем память сверх необходимого, а лишь столько памяти, сколько нужно для буферизации считанных данных. Как только найдем требуемую запись, сразу прекратим дальнейшую работу. Или можем передать найденную запись в другой поток по цепочке, например, для преобразование в другой формат, или сохранения в другой файл.

Самое большое преимущество потоков по сравнению с одновременной загрузкой всех данных состоит в том, что входные данные могут быть бесконечными и без ограничений.

Как только поток открывается, данные передаются блоками (chunks) из своего источника в процесс, потребляющий их. Поступая из файла, каждый символ или байт считывается по одному.

Модуль stream предоставляет базовый API по работе с потоками в Node.JS. Документации Node.JS вполне достаточно, чтобы разобраться в данном вопросе, но мы попытаемся составить что-то вроде шпаргалки с пояснениями некоторых моментов.

### Виды потоков

#### Есть четыре вида потоков:

- **Readable** — поток, который предоставляет данные на чтение;
- **Writable** — поток, в который данные можно записывать;
- **Duplex** — поток, из которого можно как читать данные (Readable), так и записывать в него (Writable), при этом процесс чтения и записи просиходит независимо друго от друга;
- **Transform** — разновидность Duplex потоков, которые могут изменять данные при их записи и чтении в/из потока (чаще используется как промежуточное звено в цепочке передачи данных).


Видео для лучшего пониманию потоков
- https://www.youtube.com/watch?v=TobCwECU5Bs
- https://www.youtube.com/watch?v=GpGTYp_G9VE

## Readable stream

[Видео](https://www.youtube.com/watch?v=E3tTzx0Qoj0)

### `fs.readFile` vs `streams`

По умолчанию стандарт чтения текстовых файлов есть использование `fs.readFile(filename, “utf8")`

Преимущество в node.js для `createReadStream` заключается  в том, чтобы читать файл в кусках по 16 Кбайт за раз. Как только мы прочитаем первый фрагмент, мы получим заголовок этой строки, а затем немедленно уничтожим поток, чтобы он больше не читал фрагменты. Это позволяет нам быстро работать независимо от размера файла.

И вот сравнение для чтения в CSV разных размеров, размером от 164 КБ до 160 МБ (ось х - это строки CSV / размер файла, ось у - это время, затраченное на соответствующую функцию read.js для чтения файлов):

<img src="./images/1.png">

Как вы можете видеть, `stream` метод остается в значительной степени плоским и быстрым, тогда как метод `readFile` начинает заметно возрастать, когда мы приближаемся к размеру файла размером ~ 16 МБ.

Если вы планируете иметь дело с текстовыми файлами большего размера, чем около 10 МБ, лучше всего не использовать `readFile` и вместо этого использовать потоки.

Есть еще одна вещь, чтобы упомянуть, использование потока кажется немного более быстрым при работе с файлом 100000+ строк по сравнению с меньшими размерами файлов. 

[Статья](https://medium.com/tensult/stream-and-buffer-concepts-in-node-js-87d565e151a0)

### Writable stream

В поток на запись можно послать данные используя метод `stream.write`, но прочитать их уже не получится:

`src.pipe(writableStream)`


```
var fs = require("fs");
var data = 'Simply Easy Learning';

// Create a writable stream
var writerStream = fs.createWriteStream('output.txt');

// Write the data to stream with encoding to be utf8
writerStream.write(data,'UTF8');

// Mark the end of file
writerStream.end();

// Handle stream events --> finish, and error
writerStream.on('finish', function() {
    console.log("Write completed.");
});

writerStream.on('error', function(err){
   console.log(err.stack);
});

console.log("Program Ended");

```

[Видео по Writable stream](https://www.youtube.com/watch?v=DvlCT0N7yQI)

### Преобразование данных

Потоки хороши не только для передачи данных между различными источниками и адресатами.

Когда после открытия потока данные становятся доступны, разработчики могут преобразовывать данные, поступающие из потока, до того, как они достигнут своего адресата, например, преобразовывая все символы нижнего регистра в файле в символы верхнего регистра.

Это одна из величайших сил потоков. Как только поток открывается и вы можете прочитать данные по частям, вы можете вставить различные программы в промежутке. Этот процесс показан на рисунке ниже.

### Pipe метод

Любой поток может использовать.pipe() для соединения входов с выходами.

.pipe() это просто функция, которая берет поток на чтение src и соединяет его вывод с вводом потока на запись.

Чтобы передать данные из одного потока в другой, самый простой способ вызвать над потоками метод pipe:

```
Readable.pipe(Writable);//например, по "схеме" DataBase -> File
Readable.pipe(Transform).pipe(Writable);//DataBase -> преобразовать в JSON формат -> сохранить JSON в File
Duplex.pipe(Transform).pipe(Duplex);//прочитать из DataBase -> обработать -> записать обратно в DataBase результат
```

Последняя цепочка вызовов показывает, что реализовывать свои классы потоков лучше таким образом, чтобы каждый их них решал свою задачу.

Как видно — метод pipe возвращает экземпляр потока, который был передан в него, что и позволяет потоки объединять между собой.

Метод pipe, реализован таким образом, что он решает задачу контроля «скорости» передачи данных из одного потока в другой (превышение объема внутреннего буфера потока). Например, Writable поток работает на запись медленнее, чем их передает источник данных Readable. В этом случае передача данных «приостанавливается» до тех пор, пока Writable «не сообщит» (внутренний буфер очистится), что он готов принимать следующую порцию данных.

## Создание Web-сервера на Node.js

Вот пример создания простого сервера на nod.js

```
const http = require('http');
const port = 3000;

const requestHandler = (request, response) => {
    console.log(request.url);
    response.end('Hello Node.js Server!');
};

const server = http.createServer(requestHandler);

server.listen(port, (err) => {
    if (err) {
        return console.log('something bad happened', err)
    }
    console.log(`server is listening on ${port}`)
});

```

Теперь мы можем отправить запрос на адрес `http://localhost:3000/` и получить ответ от сервера.

[Пример простого сервера и клиента с POST запросом](https://gist.github.com/umidjons/88fa0041e6dd583491dd83662d007d2c)

## Организация кода в Node.js

#### 5 основных правил структурирования проектов
Существует множество возможных способов организации Node.js-проектов и каждый из известных методов имеет свои плюсы и минусы. Однако разработчики всегда хотят добиться одного и того же: чистоты кода и возможности легко добавлять новые функции.

[5 основных правил структурирования проектов](https://medium.com/devschacht/node-hero-chapter-7-4078fa61ece6)

[Node.js app пример](https://github.com/contentful/the-example-app.nodejs) смотрите только те файлы и папки что вам нужны

## Nodemon, мониторинг изменений в файлах Node.js

Абсолютно у всех разработчиков знакомство с nodejs начинается с того, что после каждого изменения нужно перезагружать сервер. Поэтому, в этом видео мы разберем, как сделать так, чтобы сервер перегружался автоматически.

Самый популярный вариант - это nodemon. То есть идея состоит в том, что в development окружении мы хотим, чтобы nodemon следил за файлами, которые мы меняем и просто перезапускал сервер, если эти файлы относятся к серверу.

Для установки - `npm install -g nodemon`

[Видео по nodemon](https://monsterlessons.com/project/lessons/perezagruzhaem-node-s-pomoshyu-nodemon)








